Bah, disheartened for sure on Leetcode 792. Number of Matching Subsequences. I immediately thought I had a brilliant idea to store the letter positions in the target string in a default dict, so we could retrieve their relative locations in O(1) during searching. Creating the dictionary would be o(n), and then we process each word letter by letter with dict lookups so not much worse than the length of all words combined (much faster actually, as we immediately bow out once one letter fails). Nope, time limit exceeded. I really thought it was an excellent solution, but I was returning a list comprehension of the entire remaining bucket ABOVE the last position found: this means it was searching the entire bucket and doing a compare for each element. Well the bucket could be n long, so potentially n**2. That'd only work for "big buckets", meaning lots of instances of that letter... which there cant be a lot of as that would inherently reduce the size of other buckets. Returning the entire array is a foolish endevour however, as we only need the first index larger than the last position. I may keep working on my buckets solution and search the bucket myself for the smallest remaining candidate. The list comprehension LOOKS clever, but its a lot more processing than we need. Go naive.

I did peek at other peoples solutions. The str.find(match_str,start_idx,end_idx) method is supposed to be WAY WAY faster than iterating through the target string yourself. Fascinating. I need to reading on string matching algorithms, like The Boyer-Moore Fast String Searching Algorithm which is sublinear (with longer patterns). Indeed, it is far simpler and quicker to just use str.find and pass it one character at a time, failing if it returns -1 (no match). Alas, my poor dictionary approach is blown out of the water. More "the power of Python!", but I'd love to understand more how it works, rather than just using it blindly.

Speaking of Blind Magic, the map() function looks like a Wizardly Black Box. I DEFINITELY need to work on learning how to use it.  Maybe learning these two things can be my goal for the coming weekend. 
