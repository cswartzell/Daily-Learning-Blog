I've fallen out of the habbit of documentation once again, but have kept up practice daily. Really need to make notes however, as it helps to cement concepts learned daily. I should update not only this blog, but the spreadsheets for daily accomplishments, as well as the learning resources sheet. Later today maybe I'll do the work of inputting everything going back for the last few weeks. 

Speaking of daily, I've already done the LeetCode challenge for today, and completed the one for this week already. I intend to work throught the Leetcode "Explore" educational cards, as well as 2-3 Python books in the short term. Today, lets look at some explore cards.

Our first card is "Binary Trees" https://leetcode.com/explore/learn/card/data-structure-tree/. I am well familiar with the structures, but a refresh of traversal methods and terminology will be helpfu. I feel like I completely understand the advantages of tree structures, but have always been curious why storing the parent node is not standard. In these days, memory is cheap, so whats another N pointers? I guess processing cycles are "cheap" too, but extra memory for faster, simpler list traversal seems like an excellent trade off. Singly Linked Lists in particular seem so odd to me, particularly if the data they are storing is quite large, why not just one more pointer for speed of traversal? Part of this is my difficulty intuiting recursion. Ostensibly searches in these structures are pretty optomized as is, so the argument is there isnt really a need. This of course depends on the problem at hand however. Perhaps if I fully grokked the related algorithms, in particular searching them, I wwould concur that there isnt a need for "backwards" traversal afterall. More practice with BSTs might convince me as such, though I'm not sure if Ill ever agree on singly linked lists. Doing some research (links in CS ED sheet), my intuition seems correct: Its basically extra overhead on not only memory for more linking, but more operations on inserts/deletes. A doubly linked list requires you modify four pointers on a delete, accessing two different nodes. Deletes on a singly list node require updating just one pointer (and marking the node as free, handeled automatically by garbage collection depending on language). So inserts and deletes are far faster on singly linked lists...But every insert or delete has to traverse the list to find where its performing the operation. 

Anyhow! On to the card. 

For starters, we have the standard DFS (Depth First Search) traversal methods, Preorder(Root, L, R), Inorder (L, Root, R), and Postorder (L, R, Root). Pretty straightforward. "It is worth noting that when you delete nodes in a tree, deletion process will be in post-order. That is to say, when you delete a node, you will delete its left child and its right child before you delete the node itself". All three methods are trivial if implemented recursively, it's literally just a matter of ordering two calls and one return/assignement of curr_val. Inorder and Preorder are pretty straightforward to implement iteratively as well, but postorder is a little trickier: You must keep track of what values youve already processed as you temporarily revist a parent, after exhausting left branches, but DO NOT yet process it until you have also processed all its right branches. I like the method of using a tuple: (node, visited) and pushing (curr_node, False) onto the stack, then when revisiting, updating it to True as its processed, only appending your answer if visited is fales. BFS (Breadth First Search) is just level order, and using queues is pretty trivial, either for x in queue, process and push to end, or use two stacks (prev_lvl, curr_lvl)

To quote the book, on recursion: 

    "It is not easy to understand recursion and find out a recursive solution for the problem. It needs practice.
    When you meet a tree problem, ask yourself two questions: Can you determine some parameters to help the node know its answer? Can you use these parameters and the value of the node itself to determine what should be the parameters passed to its children? If the answers are both yes, try to solve this problem using a "top-down" recursive solution.

    Or, you can think of the problem in this way: for a node in a tree, if you know the answer of its children, can you calculate the answer of that node? If the answer is yes, solving the problem recursively using a bottom up approach might be a good idea."
    
    
    
    
