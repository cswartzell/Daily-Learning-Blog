Leetcode bonanza

205. Isomorphic Strings: Easy: is there a 1:1 mapping from one string to another, letter mapped to letter (Bijectively) that could transform the first string into the other? Pretty simple, used a dict to track mappings. Iterate the two strings in parallel. If there was no existing mapping, add a new one. If there was, it had better be the same, or fail out. Lastly, track (in a set) what elements have already been mapped. You could search is in dict.values() but this is an O(n) operation, where a set is at most 26 chars long, so O(1) space to keep it seperate allowing O(1) lookup. Got to use the zip() function which just returns tuples of pairs in two iterables. There is a clever solution where you can just take the set of the two lists and compare their lenghts to eachother and the set of zip(string1,string2) for a one liner

724. Find Pivot Index: A clear prefix sum question. You could go all out and use a Binary Index Tree to cut down on the amount of repeated addition, but precomputing it in its own array seemed small and easy enough. You can actually forgo storing the whole array if you iterate through the original twice, once to come up with the total sum, then accumulate and check around a pivot index. You may need to pad [0] to either end. 

1480. Running Sum of 1d Array: Literally just accumulate the array. One line. Itertools to the rescue

392. Is Subsequence: A subsequence has all its elements, in order, in another sequence, but possibly with additional elements between them "AD" is a subsequence of "ABCD". The simple solution is to iterate through each element of s1 til you run out of s2 matches in s2 either completeing the word or not. The more complex solution is to store indexes of each occurence of each letter in s2, then check for each element of s1 that there is a remaining idx for the current letter AFTER the idx of the last letter. This requires iterating through a list of indexes for each letter in s1 in the dict.


I also learned about the fascinating and complex structure of a Binary Index Tree. Well, I suppose its actually not that complex in of itself, but its use certainly takes a bit to understand. Similar to a Segment Tree, it stores some form of meta-data over a set of data, again for instance the sums of a range (a range query). It does this in an amazing fashion: It creates a tree of log(n) height and stores non-overlapping sums (in this case) in nodes of this tree using bit minipulation on the indexes of the initial data set. You decompose the index into the sum of powers of two, and add the data in each power of two index. To sum a range you then only need to sum the decomposed indecies, as the sum is already partially precomputed. To do this, you subtract the Least Significant Bit (LBS) from the index repeatedly until you have processed all the number, boom: intsant powers of two decomposition. You build the tree basically in reverse, such that the regions do not overlap when recombined. 
https://cs.stackexchange.com/questions/10538/bit-what-is-the-intuition-behind-a-binary-indexed-tree-and-how-was-it-thought-a
Id be hard pressed to give more than a hand wavey overview of its structure in an interview, and would likely not be able to code it from scratch without refference. 

One of the listed benefits is it can be used to precompute sums for a linked list, and thus to query a range on the list, you no longer have to traverse the entire list, 
