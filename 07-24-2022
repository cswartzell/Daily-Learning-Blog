Leetcode bonanza

205. Isomorphic Strings: Easy: is there a 1:1 mapping from one string to another, letter mapped to letter (Bijectively) that could transform the first string into the other? Pretty simple, used a dict to track mappings. Iterate the two strings in parallel. If there was no existing mapping, add a new one. If there was, it had better be the same, or fail out. Lastly, track (in a set) what elements have already been mapped. You could search is in dict.values() but this is an O(n) operation, where a set is at most 26 chars long, so O(1) space to keep it seperate allowing O(1) lookup. Got to use the zip() function which just returns tuples of pairs in two iterables. There is a clever solution where you can just take the set of the two lists and compare their lenghts to eachother and the set of zip(string1,string2) for a one liner

724. Find Pivot Index: A clear prefix sum question. You could go all out and use a Binary Index Tree to cut down on the amount of repeated addition, but precomputing it in its own array seemed small and easy enough. You can actually forgo storing the whole array if you iterate through the original twice, once to come up with the total sum, then accumulate and check around a pivot index. You may need to pad [0] to either end. 

1480. Running Sum of 1d Array: Literally just accumulate the array. One line. Itertools to the rescue

392. Is Subsequence: A subsequence has all its elements, in order, in another sequence, but possibly with additional elements between them "AD" is a subsequence of "ABCD". The simple solution is to iterate through each element of s1 til you run out of s2 matches in s2 either completeing the word or not. The more complex solution is to store indexes of each occurence of each letter in s2, then check for each element of s1 that there is a remaining idx for the current letter AFTER the idx of the last letter. This requires iterating through a list of indexes for each letter in s1 in the dict.
